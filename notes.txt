on a commencé par installer les dépendances  :
npx create-next-app@latest mon-app-gite
cd mon-app-gite

npm install next-auth @prisma/client prisma mysql2 bcrypt

puis prisma : 
npx prisma init --datasource-provider mysql

j'ai ensuite créé la page providers.js : 
'use client'

import { SessionProvider } from 'next-auth/react'

export function Providers({ children, session }) {
  return (
    <SessionProvider session={session}>
      {children}
    </SessionProvider>
  )
}

que j'ai importée dans le layout : 
// app/layout.js
import { Providers } from "./providers";


import "./globals.css";

export default function RootLayout({ children }) {
  return (
    <html lang="fr">
      <body >
        <Providers>
          {children}
        </Providers>
      </body>
        
      
    </html>
  );
}


et j'ai ensuite créé le authOptions pour l'identification des admins:
// app/api/auth/[...nextauth]/route.js

import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { PrismaClient } from "../../../../generated/prisma";
import bcrypt from "bcrypt";

console.log(process.env.NEXTAUTH_SECRET)
const prisma = new PrismaClient();

export const authOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Mot de passe", type: "password" },
      },
      async authorize(credentials, req) {
        const admin = await prisma.admin.findUnique({
          where: {
            email: credentials.email,
          },
        });

        if (admin) {
          const isPasswordValid = await bcrypt.compare(
            credentials.password,
            admin.password
          );

          if (isPasswordValid) {
            return {
              id: admin.id,
              email: admin.email,
            };
          }
        }
        return null;
      },
    }),
  ],
  session: {
    strategy: "jwt",
  },
  pages: {
    signIn: "api/auth/signin",
  },
  secret: process.env.NEXTAUTH_SECRET,
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      session.user.id = token.id;
      return session;
    },
  },
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


ensuite un petit formulaire de demande signin : 
// app/auth/signin/page.js
"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import Head from "next/head";

export default function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const router = useRouter();
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();

    const result = await signIn("credentials", {
      redirect: false,
      email,
      password,
    });

    if (result.error) {
      setError("Email ou mot de passe incorrect.");
    } else {
      router.push("/admin/dashboard");
    }
  };

  return (
    <>
      <Head>
        <title>Connexion Admin</title>
      </Head>
      <div className="flex items-center justify-center min-h-screen bg-gray-100">
        <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow-md">
          <h2 className="text-2xl font-bold text-center">Connexion Admin</h2>
          {error && <p className="text-sm text-red-500 text-center">{error}</p>}
          <form onSubmit={handleSubmit} className="mt-8 space-y-6">
            <div>
              <label htmlFor="email" className="sr-only">
                Email
              </label>
              <input
                id="email"
                name="email"
                type="email"
                autoComplete="email"
                required
                className="relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                placeholder="Adresse e-mail"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">
                Mot de passe
              </label>
              <input
                id="password"
                name="password"
                type="password"
                autoComplete="current-password"
                required
                className="relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                placeholder="Mot de passe"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <div>
              <button
                type="submit"
                className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              >
                Se connecter
              </button>
            </div>
          </form>
        </div>
      </div>
    </>
  );
}

la page /admin : 
'use client'

import { useEffect } from 'react'
import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'

export default function AdminPage() {
  const { data: session, status } = useSession()
  const router = useRouter()

  useEffect(() => {
    if (status === 'loading') return // Attendre le chargement

    if (session) {
      router.push('/admin/dashboard')
    } else {
      router.push('api/auth/signin')
    }
  }, [session, status, router])

  // Affichage de chargement
  return (
    <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto mb-4"></div>
        <p className="text-gray-600">Redirection...</p>
      </div>
    </div>
  )
}
et la page dashboard : 

// pages/admin/dashboard.js
'use client';
import { useSession, signOut } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import Head from "next/head";

export default function AdminDashboard() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/api/auth/signin");
    }
  }, [status, router]);

  if (status === "loading") {
    return <p>Chargement...</p>;
  }

  if (status === "authenticated") {
    return (
      <>
        <Head>
          <title>Tableau de bord Admin</title>
        </Head>
        <div className="flex items-center justify-center min-h-screen bg-gray-100">
          <div className="p-8 bg-white rounded-lg shadow-md">
            <h1 className="text-2xl font-bold mb-4">
              Bienvenue, {session.user.email}
            </h1>
            <p className="mb-4">
              Ceci est le tableau de bord de l&apos;administrateur.
            </p>
            <button
              onClick={() => signOut()}
              className="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700"
            >
              Se déconnecter
            </button>
          </div>
        </div>
      </>
    );
  }

  return null;
}


pour la partie admin et authentification admin tout est bon 

npm i lucide-react pour les tites icones

On va maintenant configurer le formulaire de contact :
npm install nodemailer react-hook-form

--> Très bien, c'est l'étape suivante logique pour ton application. On va créer cette page de demande de réservation avec un formulaire simple et une fonction pour envoyer un e-mail à l'administrateur.

Pour cela, on va utiliser une bibliothèque d'envoi d'e-mails. L'une des plus simples à mettre en place avec Next.js est Nodemailer côté serveur, et React Hook Form côté client pour gérer le formulaire.

Étape 1 : Installer les dépendances
Ouvre ton terminal et installe les bibliothèques dont on va avoir besoin :

Bash

npm install nodemailer react-hook-form
Étape 2 : Créer l'API pour l'envoi d'e-mail
On a besoin d'un point d'API pour gérer l'envoi de l'e-mail. Tu ne veux pas exposer les informations de connexion de ton service d'e-mail côté client.

Crée un nouveau fichier app/api/send-email/route.js.

JavaScript

// app/api/send-email/route.js
import nodemailer from 'nodemailer';
import { NextResponse } from 'next/server';

export async function POST(req) {
  try {
    const { name, email, phone, message, date } = await req.json();

    // Configuration du transporteur Nodemailer
    const transporter = nodemailer.createTransport({
      host: "smtp.gmail.com", // Utilise le SMTP de ton choix (Gmail, Outlook, etc.)
      port: 587,
      secure: false, // Utilise `true` pour le port 465, `false` pour le port 587
      auth: {
        user: process.env.EMAIL_USER, // Ton adresse e-mail
        pass: process.env.EMAIL_PASS, // Ton mot de passe d'application ou de compte
      },
    });

    // Options de l'e-mail
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: process.env.EMAIL_ADMIN, // L'adresse de l'administrateur pour recevoir les demandes
      subject: `Nouvelle demande de réservation de ${name}`,
      html: `
        <h1>Nouvelle demande de réservation</h1>
        <p><strong>Nom :</strong> ${name}</p>
        <p><strong>Email :</strong> ${email}</p>
        <p><strong>Téléphone :</strong> ${phone}</p>
        <p><strong>Date de réservation souhaitée :</strong> ${date}</p>
        <p><strong>Message :</strong> ${message}</p>
      `,
    };

    await transporter.sendMail(mailOptions);

    return NextResponse.json({ success: true, message: "Demande envoyée avec succès !" });

  } catch (error) {
    console.error(error);
    return NextResponse.json({ success: false, message: "Erreur lors de l'envoi de la demande." }, { status: 500 });
  }
}
